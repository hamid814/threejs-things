!function(){"use strict";var n,e={4664:function(n,e,r){var o=r(2212),i=r(2886),t=r(5260),a=r(5980),c=document.getElementById("webgl"),l=new o.WebGLRenderer({antialias:!1,canvas:c,preserveDrawingBuffer:!0});l.setSize(window.innerWidth,window.innerHeight),document.body.prepend(l.domElement),new o.Scene;var s=new o.PerspectiveCamera(20,innerWidth/innerHeight,.1,10);s.position.set(0,0,6),s.lookAt(0,0,0);var f=new o.OrthographicCamera(-1,1,1,-1,.1,1e3);f.position.set(0,0,5),f.lookAt(0,0,0),new i.OrbitControls(s,l.domElement);var p=new t.xC(l),v=new a.T({uniforms:{uTime:{value:0},resolution:{value:{x:innerWidth,y:innerHeight}},camPos:{value:s.position}},vertexShader:"#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:"#define GLSLIFY 1\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define IOR 1.45\n#define LCD 0.1 // light channel delta\n\nuniform vec3 camPos;\nuniform vec2 resolution;\nuniform float uTime;\n\nvarying vec2 vUv;\n\n// sphere\nvec3 spherePos = vec3(0.0, 0.0, 0.0);\nfloat sphereRadius = 1.0;\n// box\nvec3 box1Pos = vec3(0.0, 0.0, 0.0);\nvec3 box1Size = vec3(1.0, 1.0, 1.0);\nvec3 box2Pos = vec3(3.0, 0.0, 0.0);\nvec3 box2Size = vec3(1.0, 1.0, 1.0);\nvec3 box3Pos = vec3(0.0, 3.0, 0.0);\nvec3 box3Size = vec3(1.0, 1.0, 1.0);\nvec3 box4Pos = vec3(0.0, 0.0, 3.0);\nvec3 box4Size = vec3(1.0, 1.0, 1.0);\n// light\n// vec3 lightPos = vec3(0.5, 0.1, 10.0);\n\nmat2 Rot(float a) {\n  float s=sin(a), c=cos(a);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere( vec3 p ){\n  float sphereDist =  length(p - spherePos) - sphereRadius;\n\n  return sphereDist;\n}\n\nfloat sdPlane( vec3 p ){\n  p.xz *= Rot(3.14 + uTime);\n  float d = dot(p, normalize(vec3(0.0, 0.0, 1.0)));\n\n  return d;\n}\n\nfloat sdBox(vec3 p, vec3 position, vec3 size) {\n  // p.xz *= Rot(uTime / 3.0);\n  p.xy *= Rot(3.14 * 0.25);\n  // p.zy *= Rot(3.14 * 0.25);\n  p -= position;\n  p = abs(p) - size;\n  float morphAmount = 0.25;\n  // float morphAmount = 0.0;\n  // float morphAmount = sin(uTime) + 1.0;\n  return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.) - morphAmount;\n}\n\nfloat GetDist(vec3 p) {\n  float box1Dist = sdBox(p, box1Pos, box1Size);\n  float box2Dist = sdBox(p, box2Pos, box2Size);\n  float box3Dist = sdBox(p, box3Pos, box3Size);\n  float box4Dist = sdBox(p, box4Pos, box4Size);\n  // bd = abs(bd) - 0.2;\n  // float sd = sdSphere(p);\n  float pd = sdPlane(p);\n\n  float boxDist = min(box4Dist, min(box3Dist, min(box1Dist, box2Dist)));\n  // box1Dist = abs(box1Dist) -0.2;\n  // boxDist = abs(boxDist) -0.2;\n  // return max(pd, boxDist);\n  // return max(box1Dist, pd);\n  return min(box1Dist, MAX_DIST);\n  // return min(bd, pd);\n  // return max(bd, pd);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float inside) {\n  float dO=0.;\n    \n  for(int i=0; i<MAX_STEPS; i++) {\n    vec3 p = ro + rd*dO;\n      float dS = GetDist(p) * inside;\n      dO += dS;\n      if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n  }\n    \n  return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n  float d = GetDist(p);\n  vec2 e = vec2(.001, 0);\n  \n  vec3 n = d - vec3(\n      GetDist(p-e.xyy),\n      GetDist(p-e.yxy),\n      GetDist(p-e.yyx));\n  \n  return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize(l-p),\n      r = normalize(cross(vec3(0,1,0), f)),\n      u = cross(f,r),\n      c = f*z,\n      i = c + -uv.x*r + uv.y*u,\n      d = normalize(i);\n  return d;\n}\n\nvoid main(){\n  float ratio = resolution.x / resolution.y;\n  vec2 uv = (vUv - 0.5);\n  uv.x *= ratio;\n\n  vec3 ro = camPos;\n  vec3 rd = GetRayDir(uv, camPos, vec3(0., 0., 0.), 1.);\n\n  vec3 lightPos = GetRayDir(vec2(0.0, 0.1), camPos, vec3(0.), -1.0);\n\n  vec3 color = vec3(0.);\n\n  float d = RayMarch(camPos, rd, 1.0);\n\n  if(d<MAX_DIST) {\n      vec3 point = ro + rd * d;\n      vec3 normal = GetNormal(point);\n\n      // calc diffuse light\n      vec3 reflectedDir = reflect(rd, normal);\n      float dif = dot(reflectedDir, normalize(lightPos - point));\n      dif = (dif + 1.0) / 2.0;\n      dif *= 0.3;\n\n      color += dif;\n\n      // calc specular light\n      vec3 viewDir = normalize(camPos - point);\n      vec3 reflectDir = reflect(lightPos, normal);\n      reflectDir = normalize(reflectDir);\n      float specular = dot(viewDir, -reflectDir);\n      specular = max(0.0, specular);\n      specular = pow(specular, 256.0);\n      // specular *= 0.005;\n\n      color += specular;\n\n      // calc refraction red\n      vec3 refraction = refract(rd, normal, IOR + LCD);\n      refraction = normalize(refraction);\n      vec3 rayEnter = point - SURF_DIST * 3.0;\n      float d1 = RayMarch(rayEnter, refraction, -1.0);\n      point = point + refraction * d1;\n      normal = -GetNormal(point);\n      if(dot(refraction, refraction) == 0.0) refraction = reflect(rayEnter, normal);\n\n      // calc specular light\n      viewDir = normalize(camPos - point);\n      reflectDir = reflect(lightPos, normal);\n      reflectDir = normalize(reflectDir);\n      specular = dot(viewDir, -reflectDir);\n      specular = max(0.0, specular);\n      specular = pow(specular, 256.0);\n\n      color.r += specular;\n\n      // calc refraction green\n      refraction = refract(rd, normal, IOR);\n      refraction = normalize(refraction);\n      d1 = RayMarch(rayEnter, refraction, -1.0);\n      point = point + refraction * d1;\n      normal = -GetNormal(point);\n      if(dot(refraction, refraction) == 0.0) refraction = reflect(rayEnter, normal);\n\n      // calc specular light\n      viewDir = normalize(camPos - point);\n      reflectDir = reflect(lightPos, normal);\n      reflectDir = normalize(reflectDir);\n      specular = dot(viewDir, -reflectDir);\n      specular = max(0.0, specular);\n      specular = pow(specular, 256.0);\n\n      color.g += specular;\n\n      // calc refraction blue\n      refraction = refract(rd, normal, IOR - LCD);\n      refraction = normalize(refraction);\n      d1 = RayMarch(rayEnter, refraction, -1.0);\n      point = point + refraction * d1;\n      normal = -GetNormal(point);\n      if(dot(refraction, refraction) == 0.0) refraction = reflect(rayEnter, normal);\n\n      // calc specular light\n      viewDir = normalize(camPos - point);\n      reflectDir = reflect(lightPos, normal);\n      reflectDir = normalize(reflectDir);\n      specular = dot(viewDir, -reflectDir);\n      specular = max(0.0, specular);\n      specular = pow(specular, 256.0);\n\n      color.b += specular;\n  }\n\n  // color = pow(color, vec3(0.4545));\n  // color = mix(vec3(1.0), color, color);\n  \n  gl_FragColor = vec4(color, 1.0);\n}"});p.addPass(v);var d=0;!function n(){p.render(),d+=.03,v.uniforms.uTime.value=d,v.uniforms.camPos.value=s.position,requestAnimationFrame(n)}(),window.addEventListener("resize",(function(){l.setSize(window.innerWidth,window.innerHeight),v.uniforms.resolution.value={x:innerWidth,y:innerHeight}}))}},r={};function o(n){var i=r[n];if(void 0!==i)return i.exports;var t=r[n]={exports:{}};return e[n](t,t.exports,o),t.exports}o.m=e,n=[],o.O=function(e,r,i,t){if(!r){var a=1/0;for(s=0;s<n.length;s++){r=n[s][0],i=n[s][1],t=n[s][2];for(var c=!0,l=0;l<r.length;l++)(!1&t||a>=t)&&Object.keys(o.O).every((function(n){return o.O[n](r[l])}))?r.splice(l--,1):(c=!1,t<a&&(a=t));c&&(n.splice(s--,1),e=i())}return e}t=t||0;for(var s=n.length;s>0&&n[s-1][2]>t;s--)n[s]=n[s-1];n[s]=[r,i,t]},o.d=function(n,e){for(var r in e)o.o(e,r)&&!o.o(n,r)&&Object.defineProperty(n,r,{enumerable:!0,get:e[r]})},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},function(){var n={5436:0};o.O.j=function(e){return 0===n[e]};var e=function(e,r){var i,t,a=r[0],c=r[1],l=r[2],s=0;for(i in c)o.o(c,i)&&(o.m[i]=c[i]);if(l)var f=l(o);for(e&&e(r);s<a.length;s++)t=a[s],o.o(n,t)&&n[t]&&n[t][0](),n[a[s]]=0;return o.O(f)},r=self.webpackChunkthreejs_things=self.webpackChunkthreejs_things||[];r.forEach(e.bind(null,0)),r.push=e.bind(null,r.push.bind(r))}();var i=o.O(void 0,[2886,8792],(function(){return o(4664)}));i=o.O(i)}();