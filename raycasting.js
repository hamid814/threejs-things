!function(){"use strict";var n,e={7972:function(n,e,r){var o,t=r(6358),i=r(2212),a=r(2886),c=r(5260),l=r(5980),f=r(7219),s=("\n#define AA 1\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nuniform vec3 camPos;\nuniform vec2 resolution;\nuniform float uTime;\n\nvarying vec2 vUv;\n\nfloat refractionPower = 0.77;\nfloat lightChannelDelta = 0.02;\nfloat morphPower = 0.1;\nvec3 lights[2];\nvec3 projectedLights[2];\n\nvec3 glassColor = vec3(1.);\nfloat reflectionEffectPower = 0.1;\nfloat diff1from = 0.97;\nfloat diff2from = 0.9;\n\nstruct Scene {\n  vec3 outerSize;\n  float outerRadius;\n  vec3 light[2];\n  vec3 projectedLight[2];\n  mat4 localToWorld;\n  mat4 worldToLocal;\n} scene;\n\n".concat("\nfloat sdHexPrism( vec3 p, vec2 h ){\n  vec3 q = abs(p);\n  return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nmat4 rotateBox(in vec3 v, in float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float ic = 1. - c;\n  \n    return mat4(v.x * v.x * ic + c,       v.y * v.x * ic - s * v.z, v.z * v.x * ic + s * v.y, 0.,\n                v.x * v.y * ic + s * v.z, v.y * v.y * ic + c,       v.z * v.y * ic - s * v.x, 0.,\n                v.x * v.z * ic - s * v.y, v.y * v.z * ic + s * v.x, v.z * v.z * ic + c,       0.,\n                0.,                       0.,                       0.,                       1.);\n}\n\nvec3 ptransform(in mat4 mat, in vec3 v) {\n    return (mat * vec4(v, 1.)).xyz;\n}\n\nvec3 ntransform(in mat4 mat, in vec3 v) {\n    return (mat * vec4(v, 0.)).xyz;\n}\n","\n\nmat2 rotate(float angle) {\n  float s = sin(angle);\n  float c = cos(angle);\n  return mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 point, vec3 position, vec3 size) {\n  point += position;\n  // point.yz *= rotate(3.1415 * 0.25);\n  // point.xz *= rotate(uTime);\n  point = abs(point) - size;\n  float morphAmount = morphPower;\n  return length(max(point, 0.))+min(max(point.x, max(point.y, point.z)), 0.) - morphAmount;\n}\n\nfloat sdSphere( vec3 p, float s, vec3 pos )\n{\n  p += pos;\n  return length( p ) - s;\n}\n\nfloat sdPlane(vec3 p) {\n  // p.xz *= Rot(uTime);\n  float d = dot(p, normalize(vec3(0.0, 0.0, 1.0)));\n\n  return d;\n}\n\nfloat getDist(vec3 point) {\n  float box = sdBox(point, vec3(0.), vec3(1.));\n  return box;\n  // float box = sdBox(point, vec3(2.0, 0.0, 0.0), vec3(1.));\n  // float s = sdSphere(point, 1.4, vec3(2.0, 0.0, 0.0));\n  // float one = max(s, box);\n\n  // float box2 = sdBox(point, vec3(-2.0, 0.0, 0.0), vec3(1.));\n  // box2 = abs(box2) - 0.2;\n  // float p = sdPlane(point);\n  // float two = max(p, box2);\n  // return min(one, two);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float sign) {\n  // rd = normalize(rd);\n  float dO=0.;\n    \n  for(int i=0; i<MAX_STEPS; i++) {\n    vec3 p = ro + rd*dO;\n      float dS = getDist(p) * sign;\n      dO += dS;\n      if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n  }\n    \n  return dO;\n}\n\nvec3 getNormal(vec3 point) {\n  float d = getDist(point);\n  vec2 e = vec2(.001, 0);\n  \n  vec3 n = d - vec3(\n      getDist(point - e.xyy),\n      getDist(point - e.yxy),\n      getDist(point - e.yyx));\n  \n  return normalize(n);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget, float zoom) {\n  vec3 camForward = normalize(camTarget - camPos);\n  vec3 camRight = normalize(cross(vec3(0., 1., 0.), camForward));\n  vec3 camUp = normalize(cross(camForward, camRight));\n\n  vec3 dir = uv.x * -camRight + uv.y * camUp + zoom * camForward;\n\n  return normalize(dir);\n}\n\nfloat traceOuter1(vec3 rayOrigin, vec3 rayDirection, float eta) {\n  rayDirection = normalize(rayDirection);\n  float power = 0.;\n  // float d = roundedboxIntersectModified(rayOrigin, rayDirection, scene.outerSize, scene.outerRadius);\n  float d = rayMarch(rayOrigin, rayDirection, 1.0);\n  \n  if(d < 1e14) {\n    vec3 pos = rayOrigin + rayDirection * d;\n    // vec3 nor = -roundedboxNormal(pos, scene.outerSize, scene.outerRadius);\n    vec3 nor = -getNormal(pos);\n\n    rayDirection = -rayDirection;\n    vec3 reflection = reflect(rayDirection, nor);\n    vec3 refraction = refract(rayDirection, nor, eta);\n\n    vec3 nrefl = normalize(reflection);\n    float reflectedLight = smoothstep(diff1from, 1., dot(normalize(projectedLights[0] - pos), nrefl)) +\n      smoothstep(diff2from, 1., dot(normalize(projectedLights[1] - pos), nrefl));\n    power += reflectedLight;\n\n    float refractedLights[2];\n    refractedLights[0] = dot(normalize(lights[0] - pos), normalize(refraction));\n    refractedLights[1] = dot(normalize(lights[1] - pos), normalize(refraction));\n    float refractedLight = (smoothstep(.0, 1., refractedLights[0]) + smoothstep(.0, 1., refractedLights[1]));\n    power += refractedLight;\n  }\n\n  return power;\n}\n\nfloat traceOuter2(vec3 rayOrigin, vec3 rayDirection, float eta) {\n  rayDirection = normalize(rayDirection);\n  float power = 0.;\n  // float d = roundedboxIntersectModified(rayOrigin, rayDirection, scene.outerSize, scene.outerRadius);\n  float d = rayMarch(rayOrigin, rayDirection, 1.0);\n  \n  if(d < 1e14) {\n    vec3 pos = rayOrigin + rayDirection * d;\n    // vec3 nor = -roundedboxNormal(pos, scene.outerSize, scene.outerRadius);\n    vec3 nor = -getNormal(pos);\n\n    rayDirection = -rayDirection;\n    vec3 reflection = reflect(rayDirection, nor);\n    vec3 refraction = refract(rayDirection, nor, eta);\n\n    vec3 nrefl = normalize(reflection);\n    float reflectedLight = smoothstep(diff1from, 1., dot(normalize(projectedLights[0] - pos), nrefl)) +\n      smoothstep(diff2from, 1., dot(normalize(projectedLights[1] - pos), nrefl));\n    power += reflectedLight;\n\n    float refractedLights[2];\n    refractedLights[0] = dot(normalize(lights[0] - pos), normalize(refraction));\n    refractedLights[1] = dot(normalize(lights[1] - pos), normalize(refraction));\n    float refractedLight = (smoothstep(.0, 1., refractedLights[0]) + smoothstep(.0, 1., refractedLights[1]));\n    power += refractedLight;\n\n    power += traceOuter1(pos + reflection, -reflection, eta) * reflectionEffectPower;\n  }\n\n  return power;\n}\n\nfloat traceOuter3(vec3 rayOrigin, vec3 rayDirection, float eta) {\n  rayDirection = normalize(rayDirection);\n  float power = 0.;\n  // float d = roundedboxIntersectModified(rayOrigin, rayDirection, scene.outerSize, scene.outerRadius);\n  float d  = rayMarch(rayOrigin, rayDirection, 1.0);\n  \n  if(d < 1e14) {\n    vec3 pos = rayOrigin + rayDirection * d;\n    // vec3 nor = -roundedboxNormal(pos, scene.outerSize, scene.outerRadius);\n    vec3 nor = -getNormal(pos);\n\n    rayDirection = -rayDirection;\n    vec3 reflection = reflect(rayDirection, nor);\n    vec3 refraction = refract(rayDirection, nor, eta);\n\n    vec3 nrefl = normalize(reflection);\n    float reflectedLight = smoothstep(diff1from, 1., dot(normalize(projectedLights[0] - pos), nrefl)) +\n      smoothstep(diff2from, 1., dot(normalize(projectedLights[1] - pos), nrefl));\n    power += reflectedLight;\n\n    float refractedLights[2];\n    refractedLights[0] = dot(normalize(lights[0] - pos), normalize(refraction));\n    refractedLights[1] = dot(normalize(lights[1] - pos), normalize(refraction));\n    float refractedLight = (smoothstep(.0, 1., refractedLights[0]) + smoothstep(.0, 1., refractedLights[1]));\n    power += refractedLight;\n\n    power += traceOuter2(pos + reflection, -reflection, eta) * reflectionEffectPower;\n  }\n  return power;\n}\n\nfloat traceOuter4(vec3 rayOrigin, vec3 rayDirection, float eta) {\n  rayDirection = normalize(rayDirection);\n  float power = 0.;\n  // float d = roundedboxIntersectModified(rayOrigin, rayDirection, scene.outerSize, scene.outerRadius);\n  float d  = rayMarch(rayOrigin, rayDirection, 1.0);\n  \n  if(d < 1e14) {\n    vec3 pos = rayOrigin + rayDirection * d;\n    // vec3 nor = -roundedboxNormal(pos, scene.outerSize, scene.outerRadius);\n    vec3 nor = -getNormal(pos);\n\n    rayDirection = -rayDirection;\n    vec3 reflection = reflect(rayDirection, nor);\n    vec3 refraction = refract(rayDirection, nor, eta);\n\n    vec3 nrefl = normalize(reflection);\n    float reflectedLight = smoothstep(diff1from, 1., dot(normalize(projectedLights[0] - pos), nrefl)) +\n      smoothstep(diff2from, 1., dot(normalize(projectedLights[1] - pos), nrefl));\n    power += reflectedLight;\n\n    float refractedLights[2];\n    refractedLights[0] = dot(normalize(lights[0] - pos), normalize(refraction));\n    refractedLights[1] = dot(normalize(lights[1] - pos), normalize(refraction));\n    float refractedLight = (smoothstep(.0, 1., refractedLights[0]) + smoothstep(.0, 1., refractedLights[1]));\n    power += refractedLight;\n\n    power += traceOuter3(pos + reflection, -reflection, eta) * reflectionEffectPower;\n  }\n  return power;\n}\n\nfloat traceOuter5(vec3 rayOrigin, vec3 rayDirection, float eta) {\n  rayDirection = normalize(rayDirection);\n  float power = 0.;\n  // float d = roundedboxIntersectModified(rayOrigin, rayDirection, scene.outerSize, scene.outerRadius);\n  float d  = rayMarch(rayOrigin, rayDirection, 1.0);\n\n  if(d < MAX_DIST) {\n    vec3 pos = rayOrigin + rayDirection * d;\n    // vec3 nor = -roundedboxNormal(pos, scene.outerSize, scene.outerRadius);\n    vec3 nor = -getNormal(pos);\n\n    rayDirection = -rayDirection;\n    vec3 reflection = reflect(rayDirection, nor);\n    vec3 refraction = refract(rayDirection, nor, eta);\n\n    vec3 nrefl = normalize(reflection);\n    float reflectedLight = smoothstep(diff1from, 1., dot(normalize(projectedLights[0] - pos), nrefl)) +\n      smoothstep(diff2from, 1., dot(normalize(projectedLights[1] - pos), nrefl));\n    power += reflectedLight;\n\n    float refractedLights[2];\n    refractedLights[0] = dot(normalize(lights[0] - pos), normalize(refraction));\n    refractedLights[1] = dot(normalize(lights[1] - pos), normalize(refraction));\n    float refractedLight = (smoothstep(.0, 1., refractedLights[0]) + smoothstep(.0, 1., refractedLights[1]));\n    power += refractedLight;\n\n    power += traceOuter4(pos + reflection, -reflection, eta) * reflectionEffectPower;\n  }\n  return power;\n}\n\nvec3 trace(vec3 rayOrigin, vec3 rayDirection) {\n  // rayDirection = normalize(rayDirection);\n  vec3 power = vec3(0., 0., 0.);\n  // float d = roundedboxIntersectModified(rayOrigin, rayDirection, scene.outerSize, scene.outerRadius);\n  float d = rayMarch(rayOrigin, rayDirection, 1.0);\n  \n  if(d < MAX_DIST) {\n    // vec3 pos = rayOrigin + rayDirection * d;\n    // // vec3 nor = roundedboxNormal(pos, scene.outerSize, scene.outerRadius);\n    // vec3 nor = getNormal(pos);\n\n    // float refractionPowerR = refractionPower + lightChannelDelta;\n    // float refractionPowerB = refractionPower - lightChannelDelta;\n    // vec3 refractionR = refract(rayDirection, nor, refractionPowerR);\n    // vec3 refractionG = refract(rayDirection, nor, refractionPower);\n    // vec3 refractionB = refract(rayDirection, nor, refractionPowerB);\n\n    // power.r = traceOuter5(pos + refractionR, -refractionR, refractionPowerR);\n    // power.g = traceOuter5(pos + refractionG, -refractionG, refractionPower);\n    // power.b = traceOuter5(pos + refractionB, -refractionB, refractionPowerB);\n  }\n\n  return power;\n}\n\n// void main() {\n//   scene.localToWorld = rotateBox(normalize(vec3(0., 0., 1.)), 0.7853981633974483);\n//   scene.worldToLocal = inverse(scene.localToWorld);\n\n//   scene.outerSize = vec3(morphPower);\n//   scene.outerRadius = 1. - morphPower;\n\n//   float ratio = resolution.x / resolution.y;\n//   vec2 uv = vUv - 0.5;\n//   uv.x *= ratio;\n\n//   vec3 power = vec3(0.);\n\n//   // vec3 rayOrigin = cameraPosition;\n//   vec3 rayOrigin = camPos;\n//   vec3 ww = normalize(-rayOrigin);\n//   vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));\n//   vec3 vv = cross(uu, ww);\n\n//   vec3 rayOriginLocal = ptransform(scene.worldToLocal, rayOrigin);\n\n//   scene.light[0] = vec3(.2, 2., -.8);\n//   scene.light[1] = vec3(.2, -2., -.8);\n//   vec3 dir;\n\n//   scene.light[0] = scene.light[0].x * uu + scene.light[0].y * vv + scene.light[0].z * ww;\n//   scene.light[0] = ptransform(scene.worldToLocal, scene.light[0]);\n//   dir = normalize(-scene.light[0]);\n//   scene.projectedLight[0] = scene.light[0] + dir * roundedboxIntersectModified(scene.light[0], dir, scene.outerSize, scene.outerRadius);\n\n//   scene.light[1] = scene.light[1].x * uu + scene.light[1].y * vv + scene.light[1].z * ww;\n//   scene.light[1] = ptransform(scene.worldToLocal, scene.light[1]);\n//   dir = normalize(-scene.light[1]);\n//   scene.projectedLight[1] = scene.light[1] + dir * roundedboxIntersectModified(scene.light[1], dir, scene.outerSize, scene.outerRadius);\n\n//   vec2 p = (2. * gl_FragCoord.xy - resolution) / resolution.y;\n\n//   // vec3 rayDirection = normalize(p.x * uu + p.y * vv + 3. * ww);\n//   vec3 rayDirection = getCameraRayDir(uv, cameraPosition, vec3(0.), 1.);\n//   vec3 rayDirectionLocal = ntransform(scene.worldToLocal, rayDirection);\n\n//   // power += trace(rayOriginLocal, rayDirectionLocal);\n//   power += trace(rayOrigin, rayDirection);\n\n//   power = clamp(power, 0., 1.);\n\n//   gl_FragColor = vec4(power, 1.);\n// }\n\nvoid main() {\n  float ratio = resolution.x / resolution.y;\n  // vec2 uv = vUv - 0.5;\n  vec3 power = vec3(0.);\n\n  // ray origin\n  vec3 ro = camPos;\n  vec3 ww = normalize(-ro);\n  vec3 camForward = normalize(-ro);\n  vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));\n  vec3 camRight = normalize(cross(camForward, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = cross(uu, ww);\n  vec3 camUp = normalize(cross(camRight, camForward));\n\n  lights[0] = vec3(.2, 2., -.8);\n  lights[1] = vec3(-.2, -2., -.8);\n  vec3 dir;\n\n  lights[0] = ro + lights[0].x * camRight + lights[0].y * camUp;\n  dir = normalize(-lights[0]);\n  projectedLights[0] = lights[0] + dir * rayMarch(lights[0], dir, 1.0);\n  projectedLights[0] = lights[0];\n\n  lights[1] = ro + lights[1].x * camRight + lights[1].y * camUp;\n  dir = normalize(-lights[1]);\n  projectedLights[1] = lights[1] + dir * rayMarch(lights[1], dir, 1.0);\n  projectedLights[1] = lights[1];\n\n  #if AA > 1\n    for(int m = 0; m < AA; m++)\n    for(int n = 0; n < AA; n++)\n    {\n      vec2 aadiff = vec2(float(m), float(n)) / float(AA) - 0.0;\n      vec2 uv = (gl_FragCoord.xy + aadiff) / resolution - 0.5;\n  #else\n    vec2 uv = gl_FragCoord.xy / resolution - 0.5;\n  #endif\n  uv.x *= ratio; \n  \n  // ray direction\n  vec3 rd = getCameraRayDir(uv, ro, vec3(0.), 1.);\n  // vec3 rd = normalize(uv.x * uu + uv.y * vv + 3. * ww);\n\n  float d = rayMarch(ro, rd, 1.);\n\n  if(d < MAX_DIST) {\n    vec3 p = ro + rd * d;\n    vec3 n = getNormal(p);\n\n    float refractionPowerR = refractionPower + lightChannelDelta;\n    float refractionPowerB = refractionPower - lightChannelDelta;\n    vec3 refractionR = refract(rd, n, refractionPowerR);\n    vec3 refractionG = refract(rd, n, refractionPower);\n    vec3 refractionB = refract(rd, n, refractionPowerB);\n\n    power.r += traceOuter5(p + refractionR * 0.1, -refractionR, refractionPowerR);\n    power.g += traceOuter5(p + refractionG * 0.1, -refractionG, refractionPower);\n    power.b += traceOuter5(p + refractionB * 0.1, -refractionB, refractionPowerB);\n  }\n  #if AA > 1\n    }\n    power /= float(AA * AA);\n  #endif\n\n  power *= glassColor;\n  // power = pow(power, vec3(0.4545));\n\n  gl_FragColor = vec4(power, 1.0);\n}\n"),{boxSize:new i.Vector3(1.5,1.5,1)}),p=document.getElementById("webgl"),d=new i.WebGLRenderer({antialias:!1,canvas:p,preserveDrawingBuffer:!0});d.setSize(window.innerWidth,window.innerHeight),document.body.prepend(d.domElement);var v=(0,f.Z)();document.body.appendChild(v.domElement),new i.Scene;var m=new i.PerspectiveCamera(20,innerWidth/innerHeight,.1,10);m.position.set(-2,2,4),m.lookAt(0,0,0),new a.OrbitControls(m,d.domElement),new i.TextureLoader;var g="../../../textures/text/awesome.jpg",u=[g,g,g,g,g,g],h=(new i.CubeTextureLoader).load(u,(function(n){o.uniforms.bg.value=n,z()})),y=new c.xC(d);o=new l.T({uniforms:{uTime:{value:0},resolution:{value:{x:innerWidth,y:innerHeight}},camPos:{value:m.position},worldToCamera:{value:m.matrixWorld},boxSize:{value:s.boxSize},LCD:{value:.02},bg:{value:h}},vertexShader:"#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);\n}",fragmentShader:"#define GLSLIFY 1\nvec4 permute(vec4 x) {\n  return mod(((x * 34.0) + 1.0) * x, 289.0);\n}\nfloat permute(float x) {\n  return floor(mod(((x * 34.0) + 1.0) * x, 289.0));\n}\nvec4 taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat taylorInvSqrt(float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p, s;\n\n  p.xyz = floor(fract(vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.www;\n\n  return p;\n}\n\nfloat noise(vec4 v) {\n  const vec2 C = vec2(0.138196601125010504,  // (5 - sqrt(5))/20  G4\n  0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i = floor(v + dot(v, C.yyyy));\n  vec4 x0 = v - i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step(x0.yzw, x0.xxx);\n  vec3 isYZ = step(x0.zww, x0.yyz);\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp(i0, 0.0, 1.0);\n  vec4 i2 = clamp(i0 - 1.0, 0.0, 1.0);\n  vec4 i1 = clamp(i0 - 2.0, 0.0, 1.0);\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0);\n  float j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute(permute(permute(permute(i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0);\n\n  vec4 p0 = grad4(j0, ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4, p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * (dot(m0 * m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + dot(m1 * m1, vec2(dot(p3, x3), dot(p4, x4))));\n\n}\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define IOR 1.45\n#define RFL_STEPS 3\n#define AA 1\n\nuniform samplerCube bg;\nuniform vec3 camPos;\nuniform vec3 boxSize;\nuniform vec2 resolution;\nuniform float morphPower;\nuniform float boxThickness;\nuniform float sphereRadius;\nuniform float LCD; // ligth channel delta\nuniform float uTime;\n\nvec3[2] lights;\nvec3[2] projectedLights;\nfloat rIOR = 1.0 / IOR;\n\nstruct Reflection {\n  float power;\n  vec3 position;\n  vec3 direction;\n};\n\nmat2 rotate(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, s, -s, c);\n}\nfloat sdHexPrism(vec3 p, vec2 h) {\n  // p.yz *= rotate(uTime / 2.0);\n  // p.xz *= rotate(3.1415 * 0.5);\n  vec3 q = abs(p);\n  return max(q.z - h.y, max((q.x * 0.866025 + q.y * 0.5), q.y) - h.x);\n}\nfloat sdPlane(vec3 p) {\n  // p.xz *= Rot(uTime);\n  float d = dot(p, normalize(vec3(0.0, 0.0, 1.0)));\n  return d;\n}\nfloat sdBox(vec3 point, vec3 position, vec3 size) {\n  // point.xz *= rotate(-uTime);\n  // point.xy *= rotate(3.1415 * 0.25);\n  point += position;\n  point = abs(point) - size;\n  // float morphAmount = -0.4;\n  float morphAmount = 0.03;\n  return length(max(point, 0.)) + min(max(point.x, max(point.y, point.z)), 0.) - morphAmount;\n}\nfloat sdTorus(vec3 p, vec2 t) {\n  p.yz *= rotate(3.1415 * 0.5);\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\nfloat sdSphere(vec3 p, float s) {\n  p.z *= 2.0;\n  return length(p) - s;\n}\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\nfloat sdPyramid(in vec3 p, in float h) {\n  float m2 = h * h + 0.25;\n\n    // symmetry\n  p.xz = abs(p.xz);\n  p.xz = (p.z > p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n    // project into face plane (2D)\n  vec3 q = vec3(p.z, h * p.y - 0.5 * p.x, h * p.x + 0.5 * p.y);\n\n  float s = max(-q.x, 0.0);\n  float t = clamp((q.y - 0.5 * p.z) / (m2 + 0.25), 0.0, 1.0);\n\n  float a = m2 * (q.x + s) * (q.x + s) + q.y * q.y;\n  float b = m2 * (q.x + 0.5 * t) * (q.x + 0.5 * t) + (q.y - m2 * t) * (q.y - m2 * t);\n\n  float d2 = min(q.y, -q.x * m2 - q.y * 0.5) > 0.0 ? 0.0 : min(a, b);\n\n    // recover 3D and scale, and add sign\n  return sqrt((d2 + q.z * q.z) / m2) * sign(max(q.z, -p.y));;\n}\nfloat sdBoundingBox(vec3 p, vec3 b, float e) {\n  p = abs(p) - b;\n  vec3 q = abs(p + e) - e;\n\n  return min(min(length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0), length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)), length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\nfloat getDist(vec3 point) {\n  float time = uTime;\n  float s = sin(time) * 0.2 + 0.8;\n  float c = cos(time + 3.14 * 0.5) * 0.2 + 0.8;\n  float box = sdBox(point, vec3(0.), vec3(1.));\n  // float vastBox = sdBox(point, vec3(0.), vec3(5.0, 5.0, 0.05));\n  // box = abs(box) - 0.4;\n  // float prism = sdHexPrism(point, vec2(1.5) * c);\n  // float plane = sdPlane(point);\n\n  // noisy one:\n  // float time = uTime;\n  // point.xz *= rotate(time);\n  // float amp = 0.2;\n  float sphere = sdSphere(point, 1.5);\n  // noisep.z += cos(time) * amp;\n  // sphere += noise(vec4(noisep, sin(time) * amp)) - 0.2;\n  // return sphere * 0.4;\n  // sphere += sin(distance(point, vec3(10.0)) * 12.0 + time * 3.0) * 0.05;\n  // sphere += sin(point.y * 10.0 + time * 3.0) * 0.03;\n  // sphere += cos(point.x * 10.0 + time * 3.0) * 0.03;\n  // sphere += cos(point.z * 10.0 + time * 3.0) * 0.03;\n\n  float pyr = sdPyramid(point, 1.0);\n  float bBox = sdBoundingBox(point, vec3(1.0), 0.1);\n\n  return box;\n  // return mix(box, bBox, 0.2);\n  // return mix(box, bBox, sin(time * 0.5) * 0.5 + 0.5);\n  return smin(box, sphere, 0.1);\n}\nfloat rayMarch(vec3 ro, vec3 rd, float sign) {\n  float dO = 0.;\n\n  for(int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro + rd * dO;\n    float dS = getDist(p) * sign;\n    dO += dS;\n    if(dO > MAX_DIST || abs(dS) < SURF_DIST)\n      break;\n  }\n\n  return dO;\n}\nvec3 getNormal(vec3 point) {\n  float d = getDist(point);\n  vec2 e = vec2(.001, 0);\n\n  vec3 n = d - vec3(getDist(point - e.xyy), getDist(point - e.yxy), getDist(point - e.yyx));\n\n  return normalize(n);\n}\n\nvoid rotateLights(vec3 rayOrigin, vec3 camRight, vec3 camUp, vec3 camForward) {\n  lights[0] = rayOrigin + lights[0].x * camRight + lights[0].y * camUp + lights[0].z * camForward;\n  lights[1] = rayOrigin + lights[1].x * camRight + lights[1].y * camUp + lights[1].z * camForward;\n\n  projectedLights[0] = lights[0] + normalize(-lights[0]) * rayMarch(lights[0], normalize(-lights[0]), 1.0) * 0.95;\n  projectedLights[1] = lights[1] + normalize(-lights[1]) * rayMarch(lights[1], normalize(-lights[1]), 1.0) * 0.95;\n}\n\nfloat getDiffuse(vec3 point, vec3 normal) {\n  // return 1.0;\n  return max(0.0, dot(normalize(lights[0] - point), normal));\n}\n\nfloat getLight(vec3 ro, vec3 rd) {\n  rd = normalize(rd);\n  float power = 0.;\n\n  float d = rayMarch(ro, rd, -1.0);\n\n  if(d < MAX_DIST) {\n    vec3 p = ro + rd * d;\n    vec3 n = -getNormal(p);\n\n    vec3 reflection = reflect(rd, n);\n    reflection = normalize(reflection);\n    vec3 refraction = refract(-rd, n, rIOR);\n    refraction = normalize(refraction);\n\n    float rfl0 = dot(normalize(lights[0] - p), n);\n    rfl0 = smoothstep(0.95, 1.1, rfl0);\n    float rfl1 = dot(normalize(lights[1] - p), n);\n    rfl1 = smoothstep(0.75, 1.0, rfl1);\n\n    float rfr0 = dot(normalize(projectedLights[0] - p), refraction);\n    rfr0 = smoothstep(0.0, 1.0, rfr0);\n    float rfr1 = dot(normalize(projectedLights[1] - p), refraction);\n    rfr1 = smoothstep(0.0, 1.0, rfr1);\n\n    power += rfl0;\n    power += rfl1;\n    power += rfr0;\n    power += rfr1;\n  }\n\n  return power;\n}\n\nReflection getReflection(Reflection inReflection, int step) {\n  inReflection.direction = normalize(inReflection.direction);\n  Reflection ir = inReflection;\n\n  // out reflection\n  Reflection or;\n  or.power = 0.;\n\n  float d = rayMarch(ir.position, ir.direction, -1.0);\n  if(d < MAX_DIST) {\n    or.position = ir.position + ir.direction * d;\n    vec3 n = -getNormal(or.position);\n\n    vec3 reflection = reflect(ir.direction, n);\n    reflection = normalize(reflection);\n    vec3 refraction = refract(-ir.direction, n, rIOR);\n    refraction = normalize(refraction);\n\n    float rfl0 = dot(normalize(lights[0] - or.position), reflection);\n    rfl0 = smoothstep(0.99, 1.0, rfl0);\n    float rfl1 = dot(normalize(lights[1] - or.position), reflection);\n    rfl1 = smoothstep(0.97, 1.0, rfl1);\n\n    float rfr0 = dot(normalize(projectedLights[0] - or.position), refraction);\n    rfr0 = smoothstep(0.0, 1.0, rfr0);\n    float rfr1 = dot(normalize(projectedLights[1] - or.position), refraction);\n    rfr1 = smoothstep(0.0, 1.0, rfr1);\n\n    or.power += rfl0;\n    or.power += rfl1;\n    or.power += rfr0;\n    or.power += rfr1;\n\n    or.direction = reflection;\n    or.position = or.position + reflection;\n\n    // or.power = min(1.0, or.power);\n    or.power = clamp(or.power, 0.0, 1.0);\n    // or.power *= pow(0.5, float(step));\n  }\n\n  return or;\n}\n\nvoid main() {\n  vec3 power = vec3(0.);\n\n  vec3 rayOrigin = camPos;\n  vec3 camForward = normalize(vec3(0.) - camPos);\n  vec3 camRight = normalize(cross(camForward, vec3(0., 1., 0.)));\n  vec3 camUp = normalize(cross(camRight, camForward));\n\n  lights[0] = vec3(-0.2, 1.5, 0.0);\n  lights[1] = vec3(0.2, -1.6, 0.0);\n\n  rotateLights(rayOrigin, camRight, camUp, camForward);\n\n  #if AA > 1\n  for(int m = 0; m < AA; m++)\n    for(int n = 0; n < AA; n++) {\n      vec2 o = vec2(float(m), float(n)) / float(AA) - 0.;\n      vec2 uv = (2. * gl_FragCoord.xy + o - resolution) / resolution.y;\n      uv *= 0.5;\n  #else\n      vec2 uv = (2. * gl_FragCoord.xy - resolution) / resolution.y;\n      uv *= 0.5;\n  #endif\n\n      vec2 rotatePoint = vec2(0.25, 0.25);\n      if(distance(uv, rotatePoint) < 0.17) {\n        uv -= rotatePoint;\n\n        uv *= rotate(3.14159265);\n        power.gb -= 1.0;\n\n        uv += rotatePoint;\n      }\n      rotatePoint = vec2(-0.25, -0.25);\n      if(distance(uv, rotatePoint) < 0.1) {\n        uv -= rotatePoint;\n\n        uv *= rotate(3.14159265);\n        power.r -= 1.0;\n\n        uv += rotatePoint;\n      }\n\n      vec3 rayDirection = uv.x * camRight + uv.y * camUp + camForward;\n\n      float dist = rayMarch(rayOrigin, rayDirection, 1.0);\n\n      if(dist < MAX_DIST) {\n        vec3 point = rayOrigin + rayDirection * dist;\n        vec3 normal = getNormal(point);\n\n        vec3 refractionR = refract(rayDirection, normal, rIOR + LCD);\n        vec3 refractionG = refract(rayDirection, normal, rIOR);\n        vec3 refractionB = refract(rayDirection, normal, rIOR - LCD);\n        // power += getLight(point + refractionR, refractionR);\n        float diff = getDiffuse(point, normal);\n\n        Reflection rflR;\n        rflR.power = 0.;\n        rflR.direction = refractionR;\n        rflR.position = point + refractionR;\n\n        Reflection rflG;\n        rflG.power = 0.;\n        rflG.direction = refractionG;\n        rflG.position = point + refractionG;\n\n        Reflection rflB;\n        rflB.power = 0.;\n        rflB.direction = refractionB;\n        rflB.position = point + refractionB;\n\n        // float s = sin(uTime) * 0.5 + 0.505;\n        // int reflSteps = int(ceil(s * float(RFL_STEPS)));\n        int reflSteps = RFL_STEPS;\n\n        vec3 refColor = vec3(0.);\n\n        // for(int i = 0; i < reflSteps; i++) {\n        //   rflR = getReflection(rflR, i);\n\n        //   refColor.r += rflR.power;\n        // }\n        for(int i = 0; i < reflSteps; i++) {\n          rflG = getReflection(rflG, i);\n\n          refColor += rflG.power;\n        }\n        // for(int i = 0; i < reflSteps; i++) {\n        //   rflB = getReflection(rflB, i);\n\n        //   refColor.b += rflB.power;\n        // }\n        // power += diff;\n\n        // float time = uTime;\n        // float s = sin(time) * 0.5 + 0.5;\n        // float c = cos(time + 3.14 * 0.5) * 0.5 + 0.5;\n        power += refColor;\n        // power += diff * c;\n\n        // power += textureCube(bg, refractionR.xyz).rgb;\n        // power += textureCube(bg, rflR.direction).rgb;\n        // power += 0.1;\n      } else {\n        // uv.x /= resolution.x / resolution.y;\n        // uv += 0.5;\n        // power = textureCube(bg, rayDirection).rgb;\n        // power += vec3(1.0, 0.0, 0.0);\n      }\n#if AA > 1\n    }\n  // power /= float(AA * AA);\n#endif\n\n  power = clamp(power, 0.0, 1.0);\n  power = pow(power, vec3(0.4545));\n\n  gl_FragColor = vec4(power, 1.0);\n}\n"}),y.addPass(o);var x=0,w=0;function z(){v.update(),y.render(),x+=.025,o.uniforms.uTime.value=x,o.uniforms.camPos.value=m.position,o.uniforms.worldToCamera.value=m.matrixWorld,o.uniforms.LCD.value=.02,o.uniforms.boxSize.value=s.boxSize,requestAnimationFrame(z),w++}setTimeout((function(){var n=t.ZP.timeline();n.to(s.boxSize,{duration:1,y:1.5,ease:"power4"}),n.to(s.boxSize,{duration:.5,z:1,ease:"power4"})}),500),window.addEventListener("resize",(function(){d.setSize(window.innerWidth,window.innerHeight),o.uniforms.resolution.value={x:innerWidth,y:innerHeight}})),document.addEventListener("keydown",(function(n){"p"===n.key&&function(){try{var n="image/jpeg",e=d.domElement.toDataURL(n);b(e.replace(n,D),"glass".concat(String(w),".jpg"))}catch(n){return void console.log(n)}}()}));var D="image/octet-stream",b=function(n,e){var r=document.createElement("a");"string"==typeof r.download?(document.body.appendChild(r),r.download=e,r.href=n,r.click(),document.body.removeChild(r)):location.replace(uri)}}},r={};function o(n){var t=r[n];if(void 0!==t)return t.exports;var i=r[n]={exports:{}};return e[n](i,i.exports,o),i.exports}o.m=e,n=[],o.O=function(e,r,t,i){if(!r){var a=1/0;for(f=0;f<n.length;f++){r=n[f][0],t=n[f][1],i=n[f][2];for(var c=!0,l=0;l<r.length;l++)(!1&i||a>=i)&&Object.keys(o.O).every((function(n){return o.O[n](r[l])}))?r.splice(l--,1):(c=!1,i<a&&(a=i));c&&(n.splice(f--,1),e=t())}return e}i=i||0;for(var f=n.length;f>0&&n[f-1][2]>i;f--)n[f]=n[f-1];n[f]=[r,t,i]},o.d=function(n,e){for(var r in e)o.o(e,r)&&!o.o(n,r)&&Object.defineProperty(n,r,{enumerable:!0,get:e[r]})},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},function(){var n={5436:0};o.O.j=function(e){return 0===n[e]};var e=function(e,r){var t,i,a=r[0],c=r[1],l=r[2],f=0;for(t in c)o.o(c,t)&&(o.m[t]=c[t]);if(l)var s=l(o);for(e&&e(r);f<a.length;f++)i=a[f],o.o(n,i)&&n[i]&&n[i][0](),n[a[f]]=0;return o.O(s)},r=self.webpackChunkthreejs_things=self.webpackChunkthreejs_things||[];r.forEach(e.bind(null,0)),r.push=e.bind(null,r.push.bind(r))}();var t=o.O(void 0,[2886,6358,8943],(function(){return o(7972)}));t=o.O(t)}();